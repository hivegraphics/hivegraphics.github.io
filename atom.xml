<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Hive]]></title>
  <subtitle><![CDATA[Hive]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hive.graphics//"/>
  <updated>2015-12-22T05:25:17.846Z</updated>
  <id>http://hive.graphics//</id>
  
  <author>
    <name><![CDATA[Hive]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[是否应该在构造函数中使用this指针？]]></title>
    <link href="http://hive.graphics/2015/12/22/%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8this%E6%8C%87%E9%92%88/"/>
    <id>http://hive.graphics/2015/12/22/是否应该在构造函数中使用this指针/</id>
    <published>2015-12-21T16:00:00.000Z</published>
    <updated>2015-12-22T05:25:17.846Z</updated>
    <content type="html"><![CDATA[<p>Some people feel you should not use the this pointer in a constructor because the object is not fully formed yet. However you can use this in the constructor (in the {body} and even in the initialization list) if you are careful.</p>
<p>Here is something that always works: the {body} of a constructor (or a function called from the constructor) can reliably access the data members declared in a base class and/or the data members declared in the constructor’s own class. This is because all those data members are guaranteed to have been fully constructed by the time the constructor’s {body} starts executing.</p>
<p>Here is something that never works: the {body} of a constructor (or a function called from the constructor) cannot get down to a derived class by calling a virtual member function that is overridden in the derived class. If your goal was to get to the overridden function in the derived class, you won’t get what you want. Note that you won’t get to the override in the derived class independent of how you call the virtual member function: explicitly using the this pointer (e.g., this-&gt;method()), implicitly using the this pointer (e.g., method()), or even calling some other function that calls the virtual member function on your this object. The bottom line is this: even if the caller is constructing an object of a derived class, during the constructor of the base class, your object is not yet of that derived class. You have been warned.</p>
<p>Here is something that sometimes works: if you pass any of the data members in this object to another data member’s initializer, you must make sure that the other data member has already been initialized. The good news is that you can determine whether the other data member has (or has not) been initialized using some straightforward language rules that are independent of the particular compiler you’re using. The bad news is that you have to know those language rules (e.g., base class sub-objects are initialized first (look up the order if you have multiple and/or virtual inheritance!), then data members defined in the class are initialized in the order in which they appear in the class declaration). If you don’t know these rules, then don’t pass any data member from the this object (regardless of whether or not you explicitly use the this keyword) to any other data member’s initializer! And if you do know the rules, please be careful.</p>
<p>来自 <a href="http://www.parashift.com/c++-faq/using-this-in-ctors.html" target="_blank" rel="external">http://www.parashift.com/c++-faq/using-this-in-ctors.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Some people feel you should not use the this pointer in a constructor because the object is not fully formed yet. However you can use thi]]>
    </summary>
    
      <category term="C++知识库" scheme="http://hive.graphics/categories/C-%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不要在构造和析构函数中调用虚函数]]></title>
    <link href="http://hive.graphics/2015/12/22/%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://hive.graphics/2015/12/22/不要在构造和析构函数中调用虚函数/</id>
    <published>2015-12-21T16:00:00.000Z</published>
    <updated>2015-12-22T05:33:44.816Z</updated>
    <content type="html"><![CDATA[<p>I’ll begin with the recap: you shouldn’t call virtual functions during construction or destruction, because the calls won’t do what you think, and if they did, you’d still be unhappy. If you’re a recovering Java or C# programmer, pay close attention to this Item, because this is a place where those languages zig, while C++ zags.</p>
<p>Suppose you’ve got a class hierarchy for modeling stock transactions, e.g., buy orders, sell orders, etc. It’s important that such transactions be auditable, so each time a transaction object is created, an appropriate entry needs to be created in an audit log. This seems like a reasonable way to approach the problem:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;</span><br><span class="line">public: </span><br><span class="line">    Transaction();</span><br><span class="line">    virtual void logTransaction() const = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">    logTransaction();</span><br><span class="line">&#125;</span><br><span class="line">class BuyTransaction: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void logTransaction() const;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&#125;;</span><br><span class="line">class SellTransaction: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void logTransaction() const;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Consider what happens when this code is executed:<br>BuyTransaction b;</p>
<p>Clearly a BuyTransaction constructor will be called, but first, a Transaction constructor must be called; base class parts of derived class objects are constructed before derived class parts are. The last line of the Transaction constructor calls the virtual function logTransaction, but this is where the surprise comes in. The version of logTransaction that’s called is the one in Transaction, not the one in BuyTransaction—even though the type of object being created is BuyTransaction. During base class construction, virtual functions never go down into derived classes. Instead, the object behaves as if it were of the base type. Informally speaking, during base class construction, virtual functions aren’t.</p>
<p>There’s a good reason for this seemingly counterintuitive behavior. Because base class constructors execute before derived class constructors, derived class data members have not been initialized when base class constructors run. If virtual functions called during base class construction went down to derived classes, the derived class functions would almost certainly refer to local data members, but those data members would not yet have been initialized. That would be a non-stop ticket to undefined behavior and late-night debugging sessions. Calling down to parts of an object that have not yet been initialized is inherently dangerous, so C++ gives you no way to do it.</p>
<p>It’s actually more fundamental than that. During base class construction of a derived class object, the type of the object is that of the base class. Not only do virtual functions resolve to the base class, but the parts of the language using runtime type information (e.g., dynamic_cast (see Item 27) and typeid) treat the object as a base class type. In our example, while theTransaction constructor is running to initialize the base class part of a BuyTransaction object, the object is of type Transaction. That’s how every part of C++ will treat it, and the treatment makes sense: the BuyTransaction-specific parts of the object haven’t been initialized yet, so it’s safest to treat them as if they didn’t exist. An object doesn’t become a derived class object until execution of a derived class constructor begins.</p>
<p>The same reasoning applies during destruction. Once a derived class destructor has run, the object’s derived class data members assume undefined values, so C++ treats them as if they no longer exist. Upon entry to the base class destructor, the object becomes a base class object, and all parts of C++—virtual functions, dynamic_casts, etc.—treat it that way.</p>
<p>In the example code above, the Transaction constructor made a direct call to a virtual function, a clear and easy-to-see violation of this item’s guidance. The violation is so easy to see, some compilers issue a warning about it. (Others don’t. See Item 53 for a discussion of warnings.) Even without such a warning, the problem would almost certainly become apparent before runtime, because the logTransaction function is pure virtual in Transaction. Unless it had been defined (unlikely, but possible—see Item 34), the program wouldn’t link: the linker would be unable to find the necessary implementation of Transaction::logTransaction.</p>
<p>It’s not always so easy to detect calls to virtual functions during construction or destruction. If Transaction had multiple constructors, each of which had to perform some of the same work, it would be good software engineering to avoid code replication by putting the common initialization code, including the call to logTransaction, into a private nonvirtual initialization function, say, init:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    Transaction()</span><br><span class="line">    &#123; init(); &#125;</span><br><span class="line">virtual void logTransaction() const = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">private:</span><br><span class="line">    void init()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">...</span></span><br><span class="line">        logTransaction(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This code is conceptually the same as the earlier version, but it’s more insidious, because it will typically compile and link without complaint. In this case, because logTransaction is pure virtual in Transaction, most runtime systems will abort the program when the pure virtual is called (typically issuing a message to that effect). However, if logTransaction were a “normal” virtual function (i.e., not pure virtual) with an implementation in Transaction, that version would be called, and the program would merrily trot along, leaving you to figure out why the wrong version of logTransaction was called when a derived class object was created. The only way to avoid this problem is to make sure that none of your constructors or destructors call virtual functions on the object being created or destroyed and that all the functions they call obey the same constraint.</p>
<p>But how do you ensure that the proper version of logTransaction is called each time an object in the Transaction hierarchy is created? Clearly, calling a virtual function on the object from the Transaction constructor(s) is the wrong way to do it.</p>
<p>There are different ways to approach this problem. One is to turn logTransaction into a non-virtual function in Transaction, then require that derived class constructors pass the necessary log information to the Transaction constructor. That function can then safely call the nonvirtual logTransaction. Like this:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Transaction(const std::string&amp; logInfo);</span><br><span class="line">    void logTransaction(const std::string&amp; logInfo) const;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction(const std::string&amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">    logTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line">class BuyTransaction: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    BuyTransaction( parameters)</span><br><span class="line">    : Transaction(createLogString( parameters))</span><br><span class="line">    &#123; <span class="keyword">...</span> &#125;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">private:</span><br><span class="line">    static std::string createLogString( parameters);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In other words, since you can’t use virtual functions to call down from base classes during construction, you can compensate by having derived classes pass necessary construction information up to base class constructors instead.</p>
<p>In this example, note the use of the (private) static function createLogString in BuyTransaction. Using a helper function to create a value to pass to a base class constructor is often more convenient (and more readable) that going through contortions in the member initialization list to give the base class what it needs. By making the function static, there’s no danger of accidentally referring to the nascent BuyTransaction object’s as-yet-uninitialized data members. That’s important, because the fact that those data members will be in an undefined state is why calling virtual functions during base class construction and destruction doesn’t go down into derived classes in the first place.</p>
<p>Things to Remember: Don’t call virtual functions during construction or destruction, because such calls will never go to a more derived class than that of the currently executing constructor or destructor. </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>I’ll begin with the recap: you shouldn’t call virtual functions during construction or destruction, because the calls won’t do what you t]]>
    </summary>
    
      <category term="C++知识库" scheme="http://hive.graphics/categories/C-%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
  </entry>
  
</feed>