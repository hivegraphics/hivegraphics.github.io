<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>不要在构造和析构函数中调用虚函数 | Hive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="I’ll begin with the recap: you shouldn’t call virtual functions during construction or destruction, because the calls won’t do what you think, and if they did, you’d still be unhappy. If you’re a reco">
<meta property="og:type" content="article">
<meta property="og:title" content="不要在构造和析构函数中调用虚函数">
<meta property="og:url" content="http://hive.graphics/2015/12/22/不要在构造和析构函数中调用虚函数/index.html">
<meta property="og:site_name" content="Hive">
<meta property="og:description" content="I’ll begin with the recap: you shouldn’t call virtual functions during construction or destruction, because the calls won’t do what you think, and if they did, you’d still be unhappy. If you’re a reco">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不要在构造和析构函数中调用虚函数">
<meta name="twitter:description" content="I’ll begin with the recap: you shouldn’t call virtual functions during construction or destruction, because the calls won’t do what you think, and if they did, you’d still be unhappy. If you’re a reco">
  
  
    <link rel="icon" href="favicon.png">
  
  
 <link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,600' rel='stylesheet' type='text/css'>
 <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'>


  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  

  

  
</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/" id="logo"><i class="logo" style="background-image: url(/css/images/hive-logo-scaled.png)"></i><span class="site-title">Hive</span></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/.">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      
        <nav id="sub-nav">
          <div class="profile" id="profile-nav">
            <a id="profile-anchor" href="javascript:;"><img class="avatar" src="/css/images/HIVE.png"><i class="fa fa-caret-down"></i></a>
          </div>
        </nav>
      
      <div id="search-form-wrap">
        
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="q" value="site:http://hive.graphics"></form>
        
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
        
          <td><a class="main-nav-link" href="/.">Home</a></td>
        
          <td><a class="main-nav-link" href="/archives">Archives</a></td>
        
          <td><a class="main-nav-link" href="/categories">Categories</a></td>
        
          <td><a class="main-nav-link" href="/tags">Tags</a></td>
        
          <td><a class="main-nav-link" href="/about">About</a></td>
        
        <td>
          
            <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="搜索"><input type="hidden" name="q" value="site:http://hive.graphics"></form>
          
        </td>
      </tr>
    </table>
  </div>
</header>

    <div class="outer">
      
        <aside id="profile">
  <div class="inner profile-inner">
    <div class="base-info profile-block">
      <img id="avatar" src="/css/images/HIVE.png">
      <h2 id="name">Hive</h2>
      <h3 id="title">Computer Graphics &amp; VR</h3>
      <span id="location"><i class="fa fa-map-marker"></i>Chengdu, China</span>
      <a id="follow" href="https://github.com/hivegraphics/">关注我们</a>
    </div>
    <div class="article-info profile-block">
      <div class="article-info-block">
        2
        <span>文章</span>
      </div>
      <div class="article-info-block">
        0
        <span>标签</span>
      </div>
    </div>
    
    <div class="contact-info profile-block">
      <table class="contact-list">
        <tr>
          
          <td><a href="https://github.com/hivegraphics/" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
          
          <td><a href="/#" target="_blank" title="twitter"><i class="fa fa-twitter"></i></a></td>
          
          <td><a href="/#" target="_blank" title="facebook"><i class="fa fa-facebook"></i></a></td>
          
          <td><a href="/atom.xml" target="_blank" title="rss"><i class="fa fa-rss"></i></a></td>
          
        </tr>
      </table>
    </div>
    
    
  </div>
</aside>

      
      <section id="main"><article id="post-不要在构造和析构函数中调用虚函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      不要在构造和析构函数中调用虚函数
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2015/12/22/不要在构造和析构函数中调用虚函数/">
      <time datetime="2015-12-21T16:00:00.000Z" itemprop="datePublished">2015-12-22</time>
    </a>
  </div>


          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/C-知识库/">C++知识库</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>I’ll begin with the recap: you shouldn’t call virtual functions during construction or destruction, because the calls won’t do what you think, and if they did, you’d still be unhappy. If you’re a recovering Java or C# programmer, pay close attention to this Item, because this is a place where those languages zig, while C++ zags.</p>
<p>Suppose you’ve got a class hierarchy for modeling stock transactions, e.g., buy orders, sell orders, etc. It’s important that such transactions be auditable, so each time a transaction object is created, an appropriate entry needs to be created in an audit log. This seems like a reasonable way to approach the problem:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;</span><br><span class="line">public: </span><br><span class="line">    Transaction();</span><br><span class="line">    virtual void logTransaction() const = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">    logTransaction();</span><br><span class="line">&#125;</span><br><span class="line">class BuyTransaction: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void logTransaction() const;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&#125;;</span><br><span class="line">class SellTransaction: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void logTransaction() const;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Consider what happens when this code is executed:<br>BuyTransaction b;</p>
<p>Clearly a BuyTransaction constructor will be called, but first, a Transaction constructor must be called; base class parts of derived class objects are constructed before derived class parts are. The last line of the Transaction constructor calls the virtual function logTransaction, but this is where the surprise comes in. The version of logTransaction that’s called is the one in Transaction, not the one in BuyTransaction—even though the type of object being created is BuyTransaction. During base class construction, virtual functions never go down into derived classes. Instead, the object behaves as if it were of the base type. Informally speaking, during base class construction, virtual functions aren’t.</p>
<p>There’s a good reason for this seemingly counterintuitive behavior. Because base class constructors execute before derived class constructors, derived class data members have not been initialized when base class constructors run. If virtual functions called during base class construction went down to derived classes, the derived class functions would almost certainly refer to local data members, but those data members would not yet have been initialized. That would be a non-stop ticket to undefined behavior and late-night debugging sessions. Calling down to parts of an object that have not yet been initialized is inherently dangerous, so C++ gives you no way to do it.</p>
<p>It’s actually more fundamental than that. During base class construction of a derived class object, the type of the object is that of the base class. Not only do virtual functions resolve to the base class, but the parts of the language using runtime type information (e.g., dynamic_cast (see Item 27) and typeid) treat the object as a base class type. In our example, while theTransaction constructor is running to initialize the base class part of a BuyTransaction object, the object is of type Transaction. That’s how every part of C++ will treat it, and the treatment makes sense: the BuyTransaction-specific parts of the object haven’t been initialized yet, so it’s safest to treat them as if they didn’t exist. An object doesn’t become a derived class object until execution of a derived class constructor begins.</p>
<p>The same reasoning applies during destruction. Once a derived class destructor has run, the object’s derived class data members assume undefined values, so C++ treats them as if they no longer exist. Upon entry to the base class destructor, the object becomes a base class object, and all parts of C++—virtual functions, dynamic_casts, etc.—treat it that way.</p>
<p>In the example code above, the Transaction constructor made a direct call to a virtual function, a clear and easy-to-see violation of this item’s guidance. The violation is so easy to see, some compilers issue a warning about it. (Others don’t. See Item 53 for a discussion of warnings.) Even without such a warning, the problem would almost certainly become apparent before runtime, because the logTransaction function is pure virtual in Transaction. Unless it had been defined (unlikely, but possible—see Item 34), the program wouldn’t link: the linker would be unable to find the necessary implementation of Transaction::logTransaction.</p>
<p>It’s not always so easy to detect calls to virtual functions during construction or destruction. If Transaction had multiple constructors, each of which had to perform some of the same work, it would be good software engineering to avoid code replication by putting the common initialization code, including the call to logTransaction, into a private nonvirtual initialization function, say, init:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    Transaction()</span><br><span class="line">    &#123; init(); &#125;</span><br><span class="line">virtual void logTransaction() const = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">private:</span><br><span class="line">    void init()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">...</span></span><br><span class="line">        logTransaction(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This code is conceptually the same as the earlier version, but it’s more insidious, because it will typically compile and link without complaint. In this case, because logTransaction is pure virtual in Transaction, most runtime systems will abort the program when the pure virtual is called (typically issuing a message to that effect). However, if logTransaction were a “normal” virtual function (i.e., not pure virtual) with an implementation in Transaction, that version would be called, and the program would merrily trot along, leaving you to figure out why the wrong version of logTransaction was called when a derived class object was created. The only way to avoid this problem is to make sure that none of your constructors or destructors call virtual functions on the object being created or destroyed and that all the functions they call obey the same constraint.</p>
<p>But how do you ensure that the proper version of logTransaction is called each time an object in the Transaction hierarchy is created? Clearly, calling a virtual function on the object from the Transaction constructor(s) is the wrong way to do it.</p>
<p>There are different ways to approach this problem. One is to turn logTransaction into a non-virtual function in Transaction, then require that derived class constructors pass the necessary log information to the Transaction constructor. That function can then safely call the nonvirtual logTransaction. Like this:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Transaction(const std::string&amp; logInfo);</span><br><span class="line">    void logTransaction(const std::string&amp; logInfo) const;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction(const std::string&amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">    logTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line">class BuyTransaction: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    BuyTransaction( parameters)</span><br><span class="line">    : Transaction(createLogString( parameters))</span><br><span class="line">    &#123; <span class="keyword">...</span> &#125;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">private:</span><br><span class="line">    static std::string createLogString( parameters);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In other words, since you can’t use virtual functions to call down from base classes during construction, you can compensate by having derived classes pass necessary construction information up to base class constructors instead.</p>
<p>In this example, note the use of the (private) static function createLogString in BuyTransaction. Using a helper function to create a value to pass to a base class constructor is often more convenient (and more readable) that going through contortions in the member initialization list to give the base class what it needs. By making the function static, there’s no danger of accidentally referring to the nascent BuyTransaction object’s as-yet-uninitialized data members. That’s important, because the fact that those data members will be in an undefined state is why calling virtual functions during base class construction and destruction doesn’t go down into derived classes in the first place.</p>
<p>Things to Remember: Don’t call virtual functions during construction or destruction, because such calls will never go to a more derived class than that of the currently executing constructor or destructor. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hive.graphics/2015/12/22/不要在构造和析构函数中调用虚函数/" data-id="ciio25znf0007mw8t80197bj1" class="article-share-link">分享到</a>
      
        <a href="http://hive.graphics/2015/12/22/不要在构造和析构函数中调用虚函数/#ds-thread" class="article-comment-link">评论</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/22/是否应该在构造函数中使用this指针/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          是否应该在构造函数中使用this指针？
        
      </div>
    </a>
  
  
</nav>


  
</article>

  
  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-不要在构造和析构函数中调用虚函数" data-title="不要在构造和析构函数中调用虚函数" data-url="http://hive.graphics/2015/12/22/不要在构造和析构函数中调用虚函数/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'hivegraphics'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>

</section>
      
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul id="recent-post" class="">
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/2015/12/22/是否应该在构造函数中使用this指针/" class="thumbnail">
  
    <span class="thumbnail-image thumbnail-none"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/C-知识库/">C++知识库</a></p>
              <p class="item-title"><a href="/2015/12/22/是否应该在构造函数中使用this指针/" class="title">是否应该在构造函数中使用this指针？</a></p>
              <p class="item-date"><time datetime="2015-12-21T16:00:00.000Z" itemprop="datePublished">2015-12-22</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/2015/12/22/不要在构造和析构函数中调用虚函数/" class="thumbnail">
  
    <span class="thumbnail-image thumbnail-none"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/C-知识库/">C++知识库</a></p>
              <p class="item-title"><a href="/2015/12/22/不要在构造和析构函数中调用虚函数/" class="title">不要在构造和析构函数中调用虚函数</a></p>
              <p class="item-date"><time datetime="2015-12-21T16:00:00.000Z" itemprop="datePublished">2015-12-22</time></p>
            </div>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-知识库/">C++知识库</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
  <div id="toTop" class="fa fa-chevron-up"></div>
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Hive<br>
    </div>
  </div>
</footer>
    

<script type="text/javascript">
  var duoshuoQuery = {short_name:"hivegraphics"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>





 <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>




  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>